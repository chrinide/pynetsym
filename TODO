1. Queue unhandled messages: this may be useful. When the agent is eventually
    created, it gets all the messages. We may however have too many messages
    accumulated. Perhaps we need some pruning strategy here. [NO]
2. Catch addressing errors and? This is how erlang works. However, it may not
    be appropriate for Python. [CHECK]
4. Decorators to select what needs to be done if a method is called. E.g.,
    check that is a method meant to be called "from outside".
4b. Maybe we can create decorators to separate handles from other
    crap... Remember, if we do a separate inheritance system for handles
    we have to compute the mro with handles "statically" for efficiency.
    perhaps...
5. Do we want that we *must* specifiy the node address when creating it?
    Does this not lead to subtle bugs?: probably fixed. Now we have just
    hinting. [PARTLY FIXED] [CHECK]
6. Devise the interface for something gathering simulation results.
    Probably np.array is the right class to hold the results. Because it is
    very easy to plot/save/whatever.
7. Profile the transitive linking (regardless of how it scales).
10. Introduce the idea of an uninterruptible context that overrides
    cooperate() and that just marks that it should yield after the
    context if something happened inside
11. Introduce the idea of some "network attribute caching" to make
    things more efficient without continuosly querying the sn
12. Introduce the idea of operations run on the handle, without
    having to resort to returning the handle.
13. Create descriptors for properties that may (or may not) be
    persistent
13. Fix the whole handle thing.
14. Create "network observer that do stuff".
15. Create "agents": AI have their own greenlet + reactive stuff.
16. Create terminators that have a condition.